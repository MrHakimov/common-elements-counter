# common-elements-counter
Необходимо написать код, который эффективным образом найдёт количество общих элементов в двух массивах int-ов. Можно считать, что элементы внутри каждого массива не повторяются. Уделите внимание случаю, когда один список намного меньше другого по размеру. Кроме того, необходимо написать код, который тестирует правильность алгоритма. 

Что будет оцениваться: 
1. Правильность работы алгоритма. 
2. Скорость работы. Важна не только асимптотика, но и скрытая в ней константа. 
3. Полнота тестов. Неправильно написанный алгоритм не должен проходить ваш тест. 
4. Читаемость кода. 

В нескольких предложениях опишите используемый алгоритм, какие есть альтернативы и почему ваш алгоритм лучше. 

Рекомендуется использовать C++, но другие языки программирования тоже допустимы.

### Описание алгоритма
Дано два массива. Пусть размер меньшего массива равен `n`, а размер большего массива равен `m`. Отсортируем массив с меньшим размером - `O(n log(n))`. Теперь, пробегаясь по большему массиву будем проверять есть ли текущий элемент из большего массива в меньшем. Это можно сделать за `O(m log(n))` воспользовавшись методом двоичного поиска, так как меньший массив отсортирован. И поэтому, если текущий элемент из большего массива есть в меньшем, то увеличим значение счетчика на 1. Итого, общая асимптотика алгоритма равна `O((n + m) log(n))`.

### Альтернативы
1. **Наивная реализация - перебор**. Асимптотическое время работы такой реализации очень большое - `O(nm)`. Ее я использую для проверки корректности алгоритма, приведенного выше.
2. **Использовать set и таким образом избавиться от явного двоичного поиска**. Асимптотическое время работы не изменится, однако такая реализация использует дополнительную память.
3. **Использовать unordered_set**. В среднем такая реализация будет работать быстрее, чем приведенный мною алгоритм, так как амортизированно добавление и поиск в нем работает за `O(1)`, однако на некоторых входных данных может достигать `O((n + m) n)`, и так же используется дополнительная память.
